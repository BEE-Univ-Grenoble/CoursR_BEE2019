---
title: "Purrr"
author: "Lecaude Cresciense - Maude Cavaliere"
date: "26 septembre 2019"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##
```{r}
library(purrr)
mtcars
```

## A quoi ça sert et qu'est ce qu'est ? 

C'est un package du tidyverse.

Pour la programmation fonctionnelle : ce qui arrive dans R est le résultat d 'une fonction. Ce qui y est déjà est un objet 

Le package purrr fait intervenir principalement les fonctions de type map, les fonctions walk et safely, et est surtout utilisé pour les objets de type liste. 
Il permet d'éviter les boucles en itérant une fonction sur chaque objet de la liste.

 La sortie finale est de la même taille que l'objet initial.


##

Avant tout, que retournent ces fonctions ? 

- Celles qui retournent des listes 
    map()
    map_if()
    map_at()
- Celles qui retournent des logiques,characters,vecteurs,entiers :
  map_lgl()
  map_int()
  map_dbl()
  map_chr()
  
  ##
  
  Celles qui retournent des dataframes créés par jointure de lignes ou de colonnes 
  -map_dfr et map_dfc
  
  
  
  
  ## Structuration 
  
```{r}
map(.x, .f, ...)

```
   .x = objet 
  .f = fonction appliquée
  
```{r}
map_if(.x, .p, .f, ...)
```
  .x = objet 
  .p = sélection des éléments de .x   
  .f = fonction appliquée 
  
  ## Exemples 
  
```{r}
myX=list(c(33,NA,2,15,7,4,5),
         c(22,1,3,NA,11,2),
         c(1,5),
         c(3),
         c(12,5,9))

# deux méthodes pour faire  la moyenne de chaque liste

moyennes=vector("list",length=5)
for (i in 1:length(myX)){
  moyennes[i]=mean(myX[[i]],na.rm=TRUE)
}
print(moyennes)
```
  
```{r}
myX=list(c(33,NA,2,15,7,4,5),
         c(22,1,3,NA,11,2),
         c(1,5),
         c(3),
         c(12,5,9))
moyennes=map(myX,mean, na.rm=TRUE)
print(moyennes)
```
  
  %in% = considérant
  %>% sert à éviter l'imbrication des fonctions les unes dans les autres 
  Il peut être lu comme "ensuite" ou "puis""
  
```{r}
mtcars
mtcars %>% map(sum)

```
  Trop cool 
  
  ##

  Fait apparaître une liste des différents groupes de cyl 
```{r}
mtcars %>% 
  split(.$cyl)
```
  
```{r}
mtcars%>%
  split(.$cyl) %>%
  map(~ lm(mpg ~ wt, data = .x))
```
  Tellement nice 
  
  Rend les résultats au carré sous forme de data frame
```{r}
mtcars %>%
  split(.$cyl) %>% 
  map(~ lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map_dfr("r.squared")

```
  
  La fonction walk :
  Elle permet d'utiliser une fonction définie au préalable et d'éviter une énième boucle 
  
```{r}
print_moyenne=function(x){
  print(paste("la moyenne est de",
              mean(x,na.rm=TRUE)))
  return(NULL)
}
walk(x,print_moyenne)
```
  
  Pour éviter les problèmes 
```{r}
myX=list(c(2,5,6,7,1,0,1,1),
         c(5,1,6,4,2),
         c())
myY=list(c(5,8,9,7,22,1,9,9),
         c(2,8,9,5,4),
         c())
map2(myX,myY,reg)
```
  Soucis car le troisième objet de la liste est nul. 
  Pour faire apparaître les deux premiers qui sont bons on utilise safety()
```{r}
myX=list(c(2,5,6,7,1,0,1,1),
         c(5,1,6,4,2),
         c())
myY=list(c(5,8,9,7,22,1,9,9),
         c(2,8,9,5,4),
         c())
map2(myX,myY,safely(reg))
```
  
  