---
title: "Les Expressions régulières sous R"
author: "Ameline et Maude"
date: "6 septembre 2019"
output: ioslides_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## Introduction :

### Définition
Les expressions régulières sont des **chaînes de caractères** décrivant un *motif*, un ensemble de chaînes de caractères possible, selon une syntaxe définie.  

### Exemples

en expressions régulières le `.` correspond à tout autre caractère donc `t.t.` peut correspondre à :

- tata
- totO
- ou  tot4 

## Normes de syntaxe
Il existe 2 types de syntaxe :

- Perl-Compatible Régular Expressions (PCRE) compatible avec le code Python
- POSIX normalisé, théoriquement plus simple, plus lente

**R** utilise la norme **POSIX** par défaut.

(*la Norme PCRE s'utilise sur R à condition d'indiquer perl=TRUE*)

## Syntaxe POSIX
Quelques éléments de syntaxe pour les expressions régulières...

`.` tout caractère 
ex : tot. peut correspondre à toto tota totu etc...

`^` le motif qui suit le "^" est situé en début de chaine 
ex : ^man peut correspondre à mange mais pas démange

`$` le motif qui suit le "$" est situé en fin de chaine

`|` indique un motif alternatif
ex : to|ti sélectionnera to et ti en absence de to ? (à vérifier)

`?` 0 ou 1 occurence du motif
ex : ?bla sélectionnera toto et bla mais pas blabla

## Syntaxe POSIX

`*` 0 ou plusieurs occurences du motif
ex : *bla selectionnera toto ou blabla mais pas bla

`+` 1 ou plusieurs occurences du motif 
ex : +bla selectionnera bla et blabla mais pas toto

`[...]` le motif peut prendre un des caractères entre crochets
ex : t[oa]to peut correspondre à tato ou toto

`[^...]` le motif peut prendre tous les caracteres a l'exception de ceux qui sont indiqués entre crochets
ex : t[^u]to peut correspondre à toto, t4to mais pas à tuto


## Traitement de chaînes avec *stringr*

```{r}
library(stringr)
library(tibble)
```

*str_length* : connaître le nombre de caractères dans une chaîne de caractères                             

```{r echo=TRUE}
vec = c("chat","potté !")
str_length(vec)
```

##     

*str_sub* : connaître les caractères d'une chaîne compris entre une position de départ et une position de fin...

```{r echo=TRUE}
vec = c("chat","potté !")
str_sub(vec,2,5) # connaitre les caractères entre la 2ème et la 5ème position
```
...et possibilité de remplacer ces caractères par un nouveau.
```{r echo=TRUE}
str_sub(vec,3,3) = "u" # remplace le 3ème caractère par "u"
vec
```


## Traitement de chaînes avec *stringr*

*str_split* : on peut découper une chaîne de caractères en fonction d'un délimiteur.

```{r}
data = tibble(
  prenom= c("tim", "nahema", "thomas", "harry"),
  nom_famille = c("bale", "chouette", "dupont", "potter"),
  lieu = c("berlin-ALLEMAGNE", "nantes-FRANCE", "paris-FRANCE", "poudlard-ECOSSE"))
```

```{r echo = TRUE}
data
```


## Traitement de chaînes avec *stringr*

*str_split* : on peut découper une chaîne de caractères en fonction d'un séparateur.

```{r echo = TRUE}
str_split(data$lieu,       #notre chaîne à découper
          "-",             #le séparateur
          simplify = TRUE) #pour obtenir une matrice et pas une liste
```


## Traitement de chaînes avec *stringr*

*str_c* : on peut concaténer des chaînes de caractères entre elles (équivalent de *paste*)

```{r echo=TRUE}
data
```


## Traitement de chaînes avec *stringr*

*str_c* : concaténer des chaînes de caractères entre elles (équivalent de *paste*)

```{r echo=TRUE}
nom_prenom = str_c(data$prenom,      # 1ère chaîne à concaténer
                   data$nom_famille, # 2nde chaîne à concaténer
                   sep=" ") 
nom_prenom
```




*str_to_title* : capitaliser les éléments d’une chaîne de caractères :

```{r echo = TRUE}
data
```
```{r echo = TRUE}
str_to_title(nom_prenom)
```

## Convertir en majuscules et minuscules

Autres fonctions : </br>
 - *str_to_lower* : mettre en minuscules les éléments d’une chaîne de caractères </br>
 - *str_to_upper* : mettre en majuscules les éléments d’une chaîne de caractères

## Les principales fonctions utilisant les expressions régulières

*grep* recherche les éléments d'une chaîne de caractères (`text`) qui présentent le motif (`pattern`) indiqué.

Exemple avec le `pattern` "^cha*t" : la fonction va rechercher toutes les suites qui commencent par la chaine "ch" suivie de la lettre "a" zéro ou plusieurs fois suivie par la lettre "t".

*grep* retourne les indices de ces éléments :
            
```{r echo=TRUE}
grep("^cha*t", c("achat", "chaat", "chti"), value = FALSE)
```


##

Ou il retourne un nouveau vecteur avec les éléments qui présentent le motif si **value** = TRUE :

```{r echo=TRUE}
grep("^cha*t", c("achat", "chaat", "chti"), value = TRUE)
```



*grepl* retourne un vecteur logique selon si les éléments du vecteur présentent le motif ou non.

```{r echo=TRUE}
grepl("^cha*t", c("achat", "chaat", "chti"))
```

##

*regexpr* renvoie un vecteur de même longueur que la chaîne de caracètres, donnant la position de départ de la première correspondance ou -1 s'il n'y en a pas. Il renvoie aussi l'attribut "match.length" donnant la longueur du texte trouvé (ou -1 si pas de correspondance).

```{r echo=TRUE}
regexpr("^cha*t", c("achat", "chaat", "chti"))
```

*regexec* pareil mais retourne une liste.

## Fonctions de substitution

*sub* permet de remplacer le premier motif (`pattern`) correspondant des éléments du `text` par un nouveau caractères/chaîne de caractères (`replacement`). Elle retourne un nouveau vecteur de même longueur que le `text` avec les substitutions réalisées.

```{r echo=TRUE}
sub("cha", "CHU", c("achatchat", "chaat", "chti"))
```

*gsub* pareil mais permet de remplacer tous les motifs correspondants et non pas que le premier.

```{r echo=TRUE}
gsub("cha", "CHU", c("achatchat", "chaat", "chti"))
```





