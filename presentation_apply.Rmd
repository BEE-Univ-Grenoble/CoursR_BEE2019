---
title: "We are Apply Familly"
author: "Julia Guerra, Martial Leroy"
date: "9/6/2019"
output:
  slidy_presentation: default
  powerpoint_presentation: default
---

```{r include=FALSE}
library(utf8)

```
```{r include=FALSE}
library(htmltools)
knitr::opts_chunk$set(
  fig.align = "center"
)
knitr::knit_hooks$set(imgcenter = function(before, options, envir){
  if (before) {
    HTML("<p align='center'>")
  } else {
    HTML("</p>")
  }
})
```    

# A quoi ça sert ?


* Apply = Appliquer

A appliquer une fonction sur tout ou partie d'un objet

```{r echo=FALSE, imgcenter = TRUE}
knitr::include_graphics("https://raw.githubusercontent.com/BEE-Univ-Grenoble/CoursR_BEE2019/master/apply_family.PNG")
```


# Comment ça marche?

```{r}
df = matrix(seq(1:9), nrow = 3, ncol = 3)
df
```



Pour faire fonctionner un 'apply' :

il faut un objet l'argument 'X' :

* Vecteurs
* Matrices
* Data Frame


Il faut également une fonction à appliquer : l'argument 'FUN'


# Bien spécifier sur quoi on applique la fonction

Dans certain cas : des conditions : l'argument 'MARGIN'
L'argument 'MARGIN' indique à R sur quoi appliquer la fonction : 
* soit lignes : 1
* soit colonnes : 2



```{r echo=FALSE, imgcenter = TRUE}

knitr::include_graphics("https://raw.githubusercontent.com/BEE-Univ-Grenoble/CoursR_BEE2019/master/content_content_apply_1.png")

```






# Piege à éviter

Chaque fonction de la famille des apply, possede des specificité de sortie.

```{r}
apply(df, 1, "[") # extracting values by crossing dim 1
apply(df, 2, "[") # extracting values by crossing dim 2

```

#
```{r}
apply(df, 1, sum)     # vector of sums, by crossing dim 1
apply(df, 2, sum)     # vector of sums, by crossing dim 2

```

# sapply
```{r}
#       sapply(X, FUN)
sapply(df, "[") # returns vector

```
# vapply
```{r}
#       vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
vapply(df, "[", FUN.VALUE = c(1)) # result length = 1 bc it is a vector

```
# lapply
```{r}

#       lapply(X, FUN, ...)
lapply(df, "[") # result is list of length = 9

```
# Si on a des listes en entrée
```{r}
# on passe aux listes
lsta = list(df, cbind(df, c(20:22)), df) # list of 3 having one different-lenghted df

lsta


```
# sapply
```{r}
sapply(lsta, mean) # mean of all values in sub-objects, returns a vector


```
# vapply

# lapply
```{r}

lapply(lsta, mean) # mean of all values in sub-objects, returns a list
```


# Utilisation en imbriquant plusieurs fonction
```{r}
rowmeanfun = function(x) {apply(x, 1, mean)}
lsta[[1]]
rowmeanfun(lsta[[1]])

```


```{r}

lapply(lsta, rowmeanfun) # returns a list

```

```{r}

sapply(lsta, rowmeanfun) # returns a df if dimensions are compatible

```

```{r}

vapply(lsta, rowmeanfun, FUN.VALUE = c("row1" = 0, "row2" = 0, "row3" = 0)) # spply with security check

```

