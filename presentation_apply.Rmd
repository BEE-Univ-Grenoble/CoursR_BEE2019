---
title: "We are Apply Familly"
author: "Julia Guerra, Martial Leroy"
date: "9/6/2019"
output:
  slidy_presentation: default
  powerpoint_presentation: default
---
<<<<<<< HEAD
```{r}
knitr::opts_chunk$set(echo = FALSE)
library(utf8)
```


## A quoi ça sert ?


* Apply = Appliquer

A appliquer une fonction sur tout ou partie d'un objet

```{r echo=FALSE}

knitr::include_graphics("M:/cours/M2/bio_math/CoursR_BEE2019/apply_family.PNG")
```

<<<<<<< HEAD
## Comment ça marche?
=======
## Comment ?a marche?
```{r}
df = matrix(seq(1:9), nrow = 3, ncol = 3)
df
```
>>>>>>> d95e62d3ddc0164c0e1f9f4092bdff71f4b10995


Pour faire fonctionner un 'apply' :

il faut un objet l'argument 'X' :

* Vecteurs
* Matrices
* Data Frame

<<<<<<< HEAD
Il faut également une fonction à appliquer : l'argument 'FUN'
=======
Il faut ?galement une fonction ? appliquer : l'argument 'FUN'
>>>>>>> d95e62d3ddc0164c0e1f9f4092bdff71f4b10995

Dans certain cas : des conditions : l'argument 'MARGIN'
L'argument 'MARGIN' indique à R sur quoi appliquer la fonction : 
* soit lignes : 1
* soit colonnes : 2


<<<<<<< HEAD
## Piege à éviter
=======
```{r}
apply(df, 1, "[") # extracting values by crossing dim 1
apply(df, 2, "[") # extracting values by crossing dim 2


apply(df, 1, sum)     # vector of sums, by crossing dim 1
apply(df, 2, sum)     # vector of sums, by crossing dim 2

```

                                                  
## Piege ? ?viter
>>>>>>> d95e62d3ddc0164c0e1f9f4092bdff71f4b10995

```{r setup}
knitr::opts_chunk$set(echo = FALSE)
knitr::include_graphics("M:/cours/M2/bio_math/CoursR_BEE2019/content_content_apply_1.png")
```
Chaque fonction de la famille des aplly, possede des specificité de sortie.

<<<<<<< HEAD
lapply : Listes
vapply : Listes
sapply : 
=======
```{r}
#       sapply(X, FUN)
sapply(df, "[") # returns vector

```

```{r}
#       vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
vapply(df, "[", FUN.VALUE = c(1)) # result length = 1 bc it is a vector

```

```{r}

#       lapply(X, FUN, ...)
lapply(df, "[") # result is list of length = 9

```

```{r}
# on passe aux listes
lsta = list(df, cbind(df, c(20:22)), df) # list of 3 having one different-lenghted df

lsta


```

```{r}

lapply(lsta, mean) # mean of all values in sub-objects, returns a list

sapply(lsta, mean) # mean of all values in sub-objects, returns a vector


```


```{r}
rowmeanfun = function(x) {apply(x, 1, mean)}
lsta[[1]]
rowmeanfun(lsta[[1]])

```
>>>>>>> d95e62d3ddc0164c0e1f9f4092bdff71f4b10995

```{r}

lapply(lsta, rowmeanfun) # returns a list

```

```{r}

sapply(lsta, rowmeanfun) # returns a df if dimensions are compatible

```

```{r}

<<<<<<< HEAD

=======
vapply(lsta, rowmeanfun, FUN.VALUE = c("row1" = 0, "row2" = 0, "row3" = 0)) # spply with security check

```
>>>>>>> d95e62d3ddc0164c0e1f9f4092bdff71f4b10995

